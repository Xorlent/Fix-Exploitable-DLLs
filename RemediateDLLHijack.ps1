<#

Administrative rights are required to run this script.
This tool scans all DLLs on the C drive of a Windows PC, checks those DLLs against known expliotable DLLs.
If we have a hit, then we first see if it is a Microsoft DLL and if so, scan for a valid signature on the DLL.
If a valid signature is found, enforce Microsoft Signed DLL loading only on the subject EXE.
For all other DDLs found (associated with any 3rd party companies), simply write these findings to the CSV report.

NOTE: Always perform a backup and execute in a test environment before planning a deployment.
Many assumptions are made within the code and we do not have logic to handle these possibly crippling scenarios:
1. A vulnerable Microsoft EXE that needs to load an unsigned DLL that we have not scanned for.
2. The Microsoft DLL we found is not the one that the EXE will load (somewhat unlikely).

#>

# Get the user-specified path
$targetPath = "C:\"
$targetPath = Read-Host "Enter the starting search path (hit ENTER for the default of C:\)"

# Create the file name with the current date
$fileName = (Get-Date).ToString("yyyy-MM-dd_HH-mm") + "_Results.csv"
$rollbackPolicy = (Get-Date).ToString("yyyy-MM-dd_HH-mm") + "_Original.xml"
$newPolicy = (Get-Date).ToString("yyyy-MM-dd_HH-mm") + "_New.xml"

# Function to recursively check directories for DLL files without a valid signer certificate
function CheckDllSignatures($path) {
    $resultsList ='"Disposition","Affected EXE","Exploit","Related DLL"' + "`r`n"
    $files = Get-ChildItem -Path $path -Recurse -Filter "*.dll" -File -ErrorAction SilentlyContinue
    $hijackLibs = Invoke-RestMethod -Uri "https://hijacklibs.net/api/hijacklibs.json"

    foreach ($file in $files) {
        if($file.FullName.Contains("C:\Windows\WinSxS") -or $file.FullName.Contains("C:\Windows\SoftwareDistribution")) {
            # Ignore these files
        }
        else {
            foreach ($record in $hijackLibs -and $record.Vendor -eq "Microsoft"){
                if($file.Name -eq $record.Name){
                    $checkSignatures = Get-Childitem â€“Path 'C:\Windows','C:\Program Files','C:\Program Files(x86)','C:\ProgramData' -Include $file.Name -File -Recurse -ErrorAction SilentlyContinue
                    $SigCheck = 0
                    foreach ($dll in $checkSignatures){
                        $DLLSigCheck = Get-AuthenticodeSignature $dll.FullName -ErrorAction SilentlyContinue
                        if($DLLSigCheck.Status -eq "Valid"){
                            $SigCheck += 1
                        }
                    }
                    if($SigCheck -gt 0){
                        $splitPathEXE = $record.VulnerableExecutables[0].Path.Split("\")
                        $splitPathArrayCount = $splitPathEXE.Count - 1
                        # We found DLL with a valid signature, enforce signed DLL loading on the EXE
                        Set-ProcessMitigation -Enable MicrosoftSignedOnly -Name $splitPathEXE[$splitPathArrayCount]
                        $resultsList = $resultsList + '"AUTO-MITIGATED!'  + '","' + $record.VulnerableExecutables[0].Path + '","' + $record.VulnerableExecutables[0].Type + '","' + $file.FullName + '"' + "`r`n"
                    }
                }
                elseif($file.Name -eq $record.Name -and $record.Vendor -ne "Microsoft"){
                     $resultsList = $resultsList + '"INTERVENTION REQD'  + '","' + $record.VulnerableExecutables[0].Path + '","' + $record.VulnerableExecutables[0].Type + '","' + $file.FullName + '"' + "`r`n"
                }
            }
        }
    }
    return $resultsList
}

Get-ProcessMitigation -RegistryConfigFilePath $rollbackPolicy

# Call the function to check DLL signatures
$Matches = CheckDllSignatures $targetPath

# Save the results to a CSV file
$Matches | Out-File $fileName -Force

Get-ProcessMitigation -RegistryConfigFilePath $newPolicy

# Display a message with the file path
Write-Host "Results saved to $((Get-Location).Path)\$fileName"
Write-Host "Original Process mitigation settings saved to $((Get-Location).Path)\$rollbackPolicy"
Write-Host "New Process mitigation settings saved to $((Get-Location).Path)\$newPolicy"

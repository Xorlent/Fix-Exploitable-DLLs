<#

*************************** Administrative rights are required to run this script. *******************************
This tool loads a known expliotable DLLs list and scans all Windows paths for DLLs on the C drive of a Windows PC.
We check for a valid signature on the DLL and if one is found, enforce Microsoft Signed DLL loading on the subject EXE(s).
For all other DDLs found (associated with any 3rd party companies), simply write these findings to the CSV report.

Many assumptions are made within the code and we do not have logic to handle these possibly crippling scenarios:
1. A vulnerable Microsoft EXE that needs to load an unsigned DLL that we have not scanned for.
2. The Microsoft DLL we found is not the one that the EXE will load (somewhat unlikely).
3. A third party application that loads Microsoft DLLs in addition to other unsigned DLLs (very likely).


NOTE: Always perform a backup and execute in a test environment before planning a deployment!
#>

# Create the file name with the current date
$logFile = (Get-Date).ToString("yyyy-MM-dd_HH-mm") + '_Results.csv'
$rollbackPolicy = (Get-Date).ToString("yyyy-MM-dd_HH-mm") + '_Original.xml'
$newPolicy = (Get-Date).ToString("yyyy-MM-dd_HH-mm") + '_New.xml'

# Function to iterate through exploited DLL list, then test for valid signature and mitigate if possible.
function CheckDllSignatures() {
    $CSVHeader ='"Disposition","Rollback Cmd","Affected EXE","Exploit","Related DLL"'
    Add-Content $logFile $CSVHeader
    $hijackLibs = Invoke-RestMethod -Uri 'https://hijacklibs.net/api/hijacklibs.json'

    foreach ($record in $hijackLibs){
        if($record.Vendor -eq "Microsoft"){
            $checkSignatures = Get-Childitem -Path 'C:\Windows','C:\Program Files','C:\Program Files (x86)','C:\ProgramData' -Exclude "C:\Windows\WinSxS","C:\Windows\SoftwareDistribution" -Include $record.Name -File -Recurse -ErrorAction SilentlyContinue
            $SigCheck = 0
            foreach ($dll in $checkSignatures){
                $DLLSigCheck = Get-AuthenticodeSignature $dll.FullName -ErrorAction SilentlyContinue
                if($DLLSigCheck.Status -eq "Valid"){
                    $SigCheck += 1
                }
            }
            if($SigCheck -gt 0){
                foreach($exe in $record.VulnerableExecutables){
                    $consoleFileMsg = $exe.Path
                    Write-Host "Processing $consoleFileMsg"
                    $splitPathEXE = $exe.Path.Split("\")
                    $splitPathArrayCount = $splitPathEXE.Count - 1
                    # We found DLL with a valid signature, enforce signed DLL loading on the EXE
                    if($splitPathEXE[$splitPathArrayCount].Contains("chrome.exe")){
                        # Do nothing.  May later enhance this to read a config file with list of exceptions.
                    }
                    else {
                        Set-ProcessMitigation -Enable MicrosoftSignedOnly -Name $splitPathEXE[$splitPathArrayCount]
                        $ActionLog = '"AUTO-MITIGATED!'  + '","' + 'Set-ProcessMitigation -Disable MicrosoftSignedOnly -Name ' + $splitPathEXE[$splitPathArrayCount] + '","' + $exe.Path + '","' + $exe.Type + '","' + $record.Name + '"'
                        Add-Content $logFile $ActionLog
                    }
                }
            }
            else {
                foreach($exe in $record.VulnerableExecutables){
                    $consoleFileMsg = $exe.Path
                    Write-Host "Processing $consoleFileMsg"
                    $ActionLog = '"INTERVENTION REQD","'  + '","' + $exe.Path + '","' + $exe.Type + '","' + $record.Name + '"'
                    Add-Content $logFile $ActionLog
                }
            }
        }
        elseif($record.Vendor -ne "Microsoft"){
            foreach($exe in $record.VulnerableExecutables){
                $consoleFileMsg = $exe.Path
                Write-Host "Processing $consoleFileMsg"
                $ActionLog = '"INTERVENTION REQD","'  + '","' + $exe.Path + '","' + $exe.Type + '","' + $record.Name + '"'
                Add-Content $logFile $ActionLog
            }
        }
    }
}

# Take a backup of the original Process Mitigation configuration state
Get-ProcessMitigation -RegistryConfigFilePath $rollbackPolicy

Write-Host "Scanning and processing files...`r`n`r`n"

# Call the function to check DLL signatures
CheckDllSignatures

# Output the new Process Mitigation configuration state
Get-ProcessMitigation -RegistryConfigFilePath $newPolicy

# Display a message with output file info
Write-Host "Results saved to $((Get-Location).Path)\$logFile"
Write-Host "Original Process Mitigation settings saved to $((Get-Location).Path)\$rollbackPolicy"
Write-Host "New Process Mitigation settings saved to $((Get-Location).Path)\$newPolicy"
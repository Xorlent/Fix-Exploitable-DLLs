<#

*************************** Administrative rights are required to run this script. *******************************
This tool scans all DLLs on the C drive of a Windows PC, checks those DLLs against known expliotable DLLs.
If we have a hit, then we first see if it is a Microsoft DLL and if so, scan for a valid signature on the DLL.
If a valid signature is found, enforce Microsoft Signed DLL loading only on the subject EXE.
For all other DDLs found (associated with any 3rd party companies), simply write these findings to the CSV report.

Many assumptions are made within the code and we do not have logic to handle these possibly crippling scenarios:
1. A vulnerable Microsoft EXE that needs to load an unsigned DLL that we have not scanned for.
2. The Microsoft DLL we found is not the one that the EXE will load (somewhat unlikely).
3. A third party application that loads Microsoft DLLs in addition to other unsigned DLLs (very likely).


NOTE: Always perform a backup and execute in a test environment before planning a deployment.
#>

# Get the user-specified path
$targetPathSelect = Read-Host -prompt "Enter the starting search path (hit ENTER for the default of C:\)"
if ($targetPathSelect.Length -eq 0) {$targetPath = 'C:\'}

# Create the file name with the current date
$logFile = (Get-Date).ToString("yyyy-MM-dd_HH-mm") + '_Results.csv'
$rollbackPolicy = (Get-Date).ToString("yyyy-MM-dd_HH-mm") + '_Original.xml'
$newPolicy = (Get-Date).ToString("yyyy-MM-dd_HH-mm") + '_New.xml'

# Function to recursively check directories for DLL files, compare with known exploited DLL list,
# then test for valid signature and mitigate if possible.
#
# Receives root path to search for DLLs
function CheckDllSignatures($path) {
    $CSVHeader ='"Disposition","Rollback Cmd","Affected EXE","Exploit","Related DLL"'
    Add-Content $logFile $CSVHeader
    $files = Get-ChildItem -Path $path -Exclude "C:\Windows\WinSxS","C:\Windows\SoftwareDistribution" -Recurse -Filter "*.dll" -File -ErrorAction SilentlyContinue
    $hijackLibs = Invoke-RestMethod -Uri 'https://hijacklibs.net/api/hijacklibs.json'

    foreach ($file in $files) {
        foreach ($record in $hijackLibs){
            if($file.Name -eq $record.Name -and $record.Vendor -eq "Microsoft"){
                $checkSignatures = Get-Childitem -Path 'C:\Windows','C:\Program Files','C:\Program Files (x86)','C:\ProgramData' -Exclude "C:\Windows\WinSxS","C:\Windows\SoftwareDistribution" -Include $file.Name -File -Recurse -ErrorAction SilentlyContinue
                $SigCheck = 0
                foreach ($dll in $checkSignatures){
                    $DLLSigCheck = Get-AuthenticodeSignature $dll.FullName -ErrorAction SilentlyContinue
                    if($DLLSigCheck.Status -eq "Valid"){
                        $SigCheck += 1
                    }
                }
                if($SigCheck -gt 0){
                    foreach($exe in $record.VulnerableExecutables){
                        $consoleFileMsg = $exe.Path
                        Write-Host "Processing $consoleFileMsg"
                        $splitPathEXE = $exe.Path.Split("\")
                        $splitPathArrayCount = $splitPathEXE.Count - 1
                        # We found DLL with a valid signature, enforce signed DLL loading on the EXE
                        if($splitPathEXE[$splitPathArrayCount].Contains("chrome.exe")){
                            # Do nothing.  May enhance this to read a config file with all exceptions.
                        }
                        else {
                            Set-ProcessMitigation -Enable MicrosoftSignedOnly -Name $splitPathEXE[$splitPathArrayCount]
                            $ActionLog = '"AUTO-MITIGATED!'  + '","' + 'Set-ProcessMitigation -Disable MicrosoftSignedOnly -Name ' + $splitPathEXE[$splitPathArrayCount] + '","' + $exe.Path + '","' + $exe.Type + '","' + $file.FullName + '"'
                            Add-Content $logFile $ActionLog
                        }
                    }
                }
                else {
                    foreach($exe in $record.VulnerableExecutables){
                        $consoleFileMsg = $exe.Path
                        Write-Host "Processing $consoleFileMsg"
                        $ActionLog = '"INTERVENTION REQD","'  + '","' + $exe.Path + '","' + $exe.Type + '","' + $file.FullName + '"'
                        Add-Content $logFile $ActionLog
                    }
                }
            }
            elseif($file.Name -eq $record.Name -and $record.Vendor -ne "Microsoft"){
                foreach($exe in $record.VulnerableExecutables){
                    $consoleFileMsg = $exe.Path
                    Write-Host "Processing $consoleFileMsg"
                    $ActionLog = '"INTERVENTION REQD","'  + '","' + $exe.Path + '","' + $exe.Type + '","' + $file.FullName + '"'
                    Add-Content $logFile $ActionLog
                }
            }
        }
    }
}

# Take a backup of the original Process Mitigation configuration state
Get-ProcessMitigation -RegistryConfigFilePath $rollbackPolicy

Write-Host "Scanning and processing files (duplicates are expected as we process the Hijacklibs file)...`r`n`r`n"
# Call the function to check DLL signatures
CheckDllSignatures $targetPath

# Output the new Process Mitigation configuration state
Get-ProcessMitigation -RegistryConfigFilePath $newPolicy

# Display a message with output file info
Write-Host "Results saved to $((Get-Location).Path)\$logFile"
Write-Host "Original Process Mitigation settings saved to $((Get-Location).Path)\$rollbackPolicy"
Write-Host "New Process Mitigation settings saved to $((Get-Location).Path)\$newPolicy"